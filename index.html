<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO Pixel Pac-Man</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        body {
            background: #1a1a2e;
            font-family: 'Press Start 2P', cursive, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
            padding: 20px;
        }

        .game-container {
            position: relative;
            max-width: 800px;
            margin: 0 auto;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 32px;
            color: #ffd700;
            text-shadow: 3px 3px 0 #e62e2e;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 14px;
            color: #ff8c8c;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        #gameCanvas {
            border: 4px solid #e62e2e;
            background: #000;
            box-shadow: 0 0 30px rgba(230, 46, 46, 0.4);
            display: block;
            margin: 0 auto;
        }

        .game-ui {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
            max-width: 800px;
        }

        .ui-panel {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 3px solid;
            border-radius: 8px;
            text-align: center;
        }

        .ui-panel.score { border-color: #ffd700; }
        .ui-panel.lives { border-color: #e62e2e; }
        .ui-panel.level { border-color: #ff8c8c; }
        .ui-panel.parts { border-color: #32cd32; }

        .ui-title {
            font-size: 12px;
            margin-bottom: 8px;
            color: #ccc;
        }

        .ui-value {
            font-size: 20px;
            font-weight: bold;
        }

        .score-value { color: #ffd700; }
        .lives-value { color: #e62e2e; }
        .level-value { color: #ff8c8c; }
        .parts-value { color: #32cd32; }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            max-width: 800px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 3px solid #e62e2e;
            border-radius: 8px;
            text-align: center;
        }

        .control-title {
            color: #e62e2e;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .control-keys {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .key {
            width: 40px;
            height: 40px;
            background: #333;
            border: 2px solid #000;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 3px 0 #000;
            color: white;
        }

        .key.space {
            width: 120px;
            font-size: 12px;
        }

        .instructions {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 3px solid #ff8c8c;
            border-radius: 8px;
            margin-top: 20px;
            max-width: 800px;
        }

        .instructions h3 {
            color: #ff8c8c;
            margin-bottom: 15px;
            text-align: center;
            font-size: 16px;
        }

        .instructions p {
            margin-bottom: 8px;
            line-height: 1.5;
            font-size: 12px;
            color: #ccc;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border: 4px solid #ffd700;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            z-index: 100;
            display: none;
        }

        .modal h2 {
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #000;
        }

        .modal p {
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
        }

        .btn {
            background: linear-gradient(135deg, #e62e2e, #c41e1e);
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #000;
            box-shadow: 0 4px 0 #000;
            transition: all 0.1s;
            font-family: inherit;
        }

        .btn:hover {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #000;
        }

        .mobile-controls {
            display: none;
            margin-top: 20px;
            gap: 10px;
        }

        .mobile-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .game-ui, .controls {
                grid-template-columns: 1fr;
            }
            
            .mobile-controls {
                display: flex;
                flex-direction: column;
            }
            
            .game-title {
                font-size: 24px;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
            }
        }

        .lego-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
        }

        .power-pellet {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #e62e2e;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .bonus-item {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #32cd32;
            border: 2px solid #000;
            animation: rotate 3s infinite linear;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">LEGO PIXEL PAC-MAN</h1>
            <div class="game-subtitle">Собери все детали LEGO и избегай призраков-минифигурок!</div>
        </div>

        <div class="game-ui">
            <div class="ui-panel score">
                <div class="ui-title">СЧЁТ</div>
                <div class="ui-value score-value" id="score">0</div>
            </div>
            <div class="ui-panel lives">
                <div class="ui-title">ЖИЗНИ</div>
                <div class="ui-value lives-value" id="lives">3</div>
            </div>
            <div class="ui-panel level">
                <div class="ui-title">УРОВЕНЬ</div>
                <div class="ui-value level-value" id="level">1</div>
            </div>
            <div class="ui-panel parts">
                <div class="ui-title">ДЕТАЛИ</div>
                <div class="ui-value parts-value" id="parts">0/150</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div class="controls">
            <div class="control-group">
                <div class="control-title">УПРАВЛЕНИЕ ДВИЖЕНИЕМ</div>
                <div class="control-keys">
                    <div class="key">←</div>
                    <div class="key">↑</div>
                    <div class="key">→</div>
                    <div class="key">↓</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-title">ДЕЙСТВИЯ</div>
                <div class="control-keys">
                    <div class="key space">ПРОБЕЛ</div>
                </div>
            </div>
        </div>

        <div class="mobile-controls">
            <div class="mobile-row">
                <div class="mobile-btn" id="upBtn">↑</div>
            </div>
            <div class="mobile-row">
                <div class="mobile-btn" id="leftBtn">←</div>
                <div class="mobile-btn" id="downBtn">↓</div>
                <div class="mobile-btn" id="rightBtn">→</div>
            </div>
        </div>

        <div class="instructions">
            <h3>КАК ИГРАТЬ</h3>
            <p>• Управляйте LEGO минифигуркой с помощью стрелок</p>
            <p>• Собирайте все детали LEGO (жёлтые точки)</p>
            <p>• Красные точки дают временную силу против призраков</p>
            <p>• Зелёные бонусы дают дополнительные очки</p>
            <p>• Избегайте призраков-минифигурок</p>
        </div>

        <div id="gameOver" class="modal">
            <h2>ИГРА ОКОНЧЕНА!</h2>
            <p>Ваш счёт: <span id="finalScore">0</span></p>
            <button class="btn" onclick="restartGame()">ИГРАТЬ СНОВА</button>
        </div>

        <div id="levelComplete" class="modal">
            <h2>УРОВЕНЬ ПРОЙДЕН!</h2>
            <p>Переходим на следующий уровень!</p>
            <button class="btn" onclick="nextLevel()">ПРОДОЛЖИТЬ</button>
        </div>
    </div>

    <script>
        // Константы игры
        const TILE_SIZE = 25;
        const GRID_WIDTH = 32;
        const GRID_HEIGHT = 20;
        const CANVAS_WIDTH = GRID_WIDTH * TILE_SIZE;
        const CANVAS_HEIGHT = GRID_HEIGHT * TILE_SIZE;

        // Типы клеток
        const WALL = 0;
        const PATH = 1;
        const DOT = 2;
        const POWER_DOT = 3;
        const BONUS = 4;

        // Направления
        const UP = 0;
        const RIGHT = 1;
        const DOWN = 2;
        const LEFT = 3;

        // Инициализация canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Игровые переменные
        let player, ghosts = [];
        let score = 0;
        let lives = 3;
        let level = 1;
        let dotsCollected = 0;
        let totalDots = 0;
        let powerMode = false;
        let powerModeTimer = 0;
        let gameRunning = true;
        let lastTime = 0;
        let grid = [];

        // Элементы интерфейса
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const partsEl = document.getElementById('parts');
        const gameOverEl = document.getElementById('gameOver');
        const levelCompleteEl = document.getElementById('levelComplete');
        const finalScoreEl = document.getElementById('finalScore');

        // Создание уровня с более коридорной структурой
        function createLevel() {
            grid = [];
            totalDots = 0;
            
            // Сначала создаем все стены
            for (let y = 0; y < GRID_HEIGHT; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Границы
                    if (x === 0 || y === 0 || x === GRID_WIDTH - 1 || y === GRID_HEIGHT - 1) {
                        grid[y][x] = WALL;
                    } else {
                        grid[y][x] = WALL;
                    }
                }
            }

            // Создаем основные коридоры
            createMainCorridors();
            
            // Добавляем дополнительные проходы для связности
            createAdditionalPaths();
            
            // Добавляем точки и бонусы
            addDotsAndBonuses();
            
            dotsCollected = 0;
            updateUI();
        }

        function createMainCorridors() {
            // Вертикальные коридоры
            for (let x = 2; x < GRID_WIDTH - 2; x += 4) {
                for (let y = 2; y < GRID_HEIGHT - 2; y++) {
                    grid[y][x] = PATH;
                }
            }
            
            // Горизонтальные коридоры
            for (let y = 2; y < GRID_HEIGHT - 2; y += 4) {
                for (let x = 2; x < GRID_WIDTH - 2; x++) {
                    grid[y][x] = PATH;
                }
            }
            
            // Перекрестки
            for (let y = 2; y < GRID_HEIGHT - 2; y += 4) {
                for (let x = 2; x < GRID_WIDTH - 2; x += 4) {
                    // Создаем перекресток
                    grid[y][x] = PATH;
                    
                    // Добавляем соединения между коридорами
                    if (x > 2) grid[y][x-1] = PATH;
                    if (x < GRID_WIDTH - 3) grid[y][x+1] = PATH;
                    if (y > 2) grid[y-1][x] = PATH;
                    if (y < GRID_HEIGHT - 3) grid[y+1][x] = PATH;
                }
            }
        }

        function createAdditionalPaths() {
            // Создаем дополнительные соединения для лучшей связности
            for (let y = 4; y < GRID_HEIGHT - 4; y += 8) {
                for (let x = 4; x < GRID_WIDTH - 4; x += 8) {
                    // Случайные соединения между коридорами
                    if (Math.random() < 0.7) {
                        if (x + 2 < GRID_WIDTH - 2) {
                            grid[y][x+1] = PATH;
                            grid[y][x+2] = PATH;
                        }
                    }
                    
                    if (Math.random() < 0.7) {
                        if (y + 2 < GRID_HEIGHT - 2) {
                            grid[y+1][x] = PATH;
                            grid[y+2][x] = PATH;
                        }
                    }
                }
            }
        }

        function addDotsAndBonuses() {
            for (let y = 1; y < GRID_HEIGHT - 1; y++) {
                for (let x = 1; x < GRID_WIDTH - 1; x++) {
                    if (grid[y][x] === PATH) {
                        const rand = Math.random();
                        if (rand < 0.7) {
                            grid[y][x] = DOT;
                            totalDots++;
                        } else if (rand < 0.85) {
                            grid[y][x] = POWER_DOT;
                            totalDots++;
                        } else if (rand < 0.95) {
                            grid[y][x] = BONUS;
                        }
                    }
                }
            }
            
            // Убедимся, что начальная позиция игрока свободна
            grid[1][1] = PATH;
            grid[1][2] = PATH;
            grid[2][1] = PATH;
        }

        // Класс игрока
        class Player {
            constructor() {
                this.reset();
                this.color = '#32CD32'; // Зеленый цвет для главного персонажа
                this.animationFrame = 0;
                this.mouthOpen = true;
            }

            reset() {
                this.x = 1 * TILE_SIZE + TILE_SIZE / 2;
                this.y = 1 * TILE_SIZE + TILE_SIZE / 2;
                this.direction = RIGHT;
                this.nextDirection = RIGHT;
                this.speed = 2;
                this.gridX = 1;
                this.gridY = 1;
            }

            update(deltaTime) {
                this.animationFrame += deltaTime * 10;
                if (this.animationFrame >= 10) {
                    this.mouthOpen = !this.mouthOpen;
                    this.animationFrame = 0;
                }

                // Обновляем позицию в сетке
                this.gridX = Math.floor(this.x / TILE_SIZE);
                this.gridY = Math.floor(this.y / TILE_SIZE);

                // Проверка возможности движения в выбранном направлении
                if (this.canMove(this.nextDirection)) {
                    this.direction = this.nextDirection;
                }

                // Движение
                if (this.canMove(this.direction)) {
                    switch (this.direction) {
                        case UP: this.y -= this.speed; break;
                        case RIGHT: this.x += this.speed; break;
                        case DOWN: this.y += this.speed; break;
                        case LEFT: this.x -= this.speed; break;
                    }
                }

                // Телепортация через туннели
                if (this.x < 0) this.x = CANVAS_WIDTH - TILE_SIZE / 2;
                if (this.x >= CANVAS_WIDTH) this.x = TILE_SIZE / 2;

                // Сбор точек
                this.collectDots();
            }

            canMove(direction) {
                let testGridX = this.gridX;
                let testGridY = this.gridY;

                switch (direction) {
                    case UP: testGridY--; break;
                    case RIGHT: testGridX++; break;
                    case DOWN: testGridY++; break;
                    case LEFT: testGridX--; break;
                }

                return grid[testGridY] && grid[testGridY][testGridX] !== WALL;
            }

            collectDots() {
                if (grid[this.gridY][this.gridX] === DOT) {
                    grid[this.gridY][this.gridX] = PATH;
                    score += 10;
                    dotsCollected++;
                    updateUI();
                } else if (grid[this.gridY][this.gridX] === POWER_DOT) {
                    grid[this.gridY][this.gridX] = PATH;
                    score += 50;
                    dotsCollected++;
                    powerMode = true;
                    powerModeTimer = 300;
                    updateUI();
                } else if (grid[this.gridY][this.gridX] === BONUS) {
                    grid[this.gridY][this.gridX] = PATH;
                    score += 100;
                    updateUI();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Тело минифигурки (пиксель-арт)
                ctx.fillStyle = this.color;
                
                // Голова
                ctx.fillRect(-6, -10, 12, 8);
                
                // Тело
                ctx.fillRect(-8, -2, 16, 12);
                
                // Ноги
                ctx.fillRect(-6, 10, 5, 4);
                ctx.fillRect(1, 10, 5, 4);
                
                // Руки
                ctx.fillRect(-10, 0, 4, 8);
                ctx.fillRect(6, 0, 4, 8);
                
                // Лицо
                ctx.fillStyle = '#000';
                ctx.fillRect(-4, -8, 2, 2);
                ctx.fillRect(2, -8, 2, 2);
                
                // Рот (анимированный)
                if (this.mouthOpen) {
                    ctx.fillStyle = '#000';
                    if (this.direction === RIGHT) {
                        ctx.fillRect(4, -6, 2, 4);
                    } else if (this.direction === LEFT) {
                        ctx.fillRect(-6, -6, 2, 4);
                    } else if (this.direction === UP) {
                        ctx.fillRect(-2, -12, 4, 2);
                    } else {
                        ctx.fillRect(-2, 0, 4, 2);
                    }
                }

                // Эффект силы
                if (powerMode) {
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            setDirection(direction) {
                this.nextDirection = direction;
            }
        }

        // Класс призраков
        class Ghost {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.direction = RIGHT;
                this.speed = 1;
                this.frightened = false;
                this.gridX = Math.floor(x / TILE_SIZE);
                this.gridY = Math.floor(y / TILE_SIZE);
                this.animation = 0;
            }

            update(deltaTime) {
                this.animation += deltaTime * 8;
                
                // AI призрака
                if (Math.random() < 0.02 || !this.canMove(this.direction)) {
                    this.findNewDirection();
                }

                // Движение
                if (this.canMove(this.direction)) {
                    switch (this.direction) {
                        case UP: this.y -= this.speed; break;
                        case RIGHT: this.x += this.speed; break;
                        case DOWN: this.y += this.speed; break;
                        case LEFT: this.x -= this.speed; break;
                    }
                }

                // Обновляем позицию в сетке
                this.gridX = Math.floor(this.x / TILE_SIZE);
                this.gridY = Math.floor(this.y / TILE_SIZE);

                // Телепортация
                if (this.x < 0) this.x = CANVAS_WIDTH - TILE_SIZE / 2;
                if (this.x >= CANVAS_WIDTH) this.x = TILE_SIZE / 2;
            }

            canMove(direction) {
                let testGridX = this.gridX;
                let testGridY = this.gridY;

                switch (direction) {
                    case UP: testGridY--; break;
                    case RIGHT: testGridX++; break;
                    case DOWN: testGridY++; break;
                    case LEFT: testGridX--; break;
                }

                return grid[testGridY] && grid[testGridY][testGridX] !== WALL;
            }

            findNewDirection() {
                const directions = [];
                for (let dir = 0; dir < 4; dir++) {
                    if (dir !== (this.direction + 2) % 4 && this.canMove(dir)) {
                        directions.push(dir);
                    }
                }
                
                if (directions.length > 0) {
                    this.direction = directions[Math.floor(Math.random() * directions.length)];
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Тело призрака в стиле LEGO
                if (this.frightened) {
                    ctx.fillStyle = powerMode ? '#0000FF' : '#6666FF';
                } else {
                    ctx.fillStyle = this.color;
                }
                
                // Основное тело
                ctx.fillRect(-8, -8, 16, 16);
                
                // Волнистый низ
                const wave = Math.sin(this.animation) * 2;
                ctx.beginPath();
                ctx.moveTo(-8, 8);
                for (let i = -6; i <= 6; i += 4) {
                    ctx.lineTo(i, 8 + wave);
                }
                ctx.lineTo(8, 8);
                ctx.fill();

                // Глаза
                ctx.fillStyle = '#FFF';
                ctx.fillRect(-5, -4, 3, 3);
                ctx.fillRect(2, -4, 3, 3);
                
                ctx.fillStyle = '#000';
                ctx.fillRect(-4, -3, 2, 2);
                ctx.fillRect(3, -3, 2, 2);

                // LEGO кружок на голове
                ctx.fillStyle = this.frightened ? '#4444FF' : '#8B0000';
                ctx.beginPath();
                ctx.arc(0, -4, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Отрисовка уровня
        function drawLevel() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;

                    if (grid[y][x] === WALL) {
                        // Стены в стиле LEGO
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                        
                        // Текстура LEGO
                        ctx.fillStyle = '#A52A2A';
                        ctx.fillRect(tileX + 5, tileY + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                        
                        // Кружок LEGO
                        ctx.fillStyle = '#5C0000';
                        ctx.beginPath();
                        ctx.arc(tileX + TILE_SIZE/2, tileY + TILE_SIZE/2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (grid[y][x] === DOT) {
                        // Точки
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(tileX + TILE_SIZE/2, tileY + TILE_SIZE/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (grid[y][x] === POWER_DOT) {
                        // Большие точки
                        ctx.fillStyle = '#E62E2E';
                        ctx.beginPath();
                        ctx.arc(tileX + TILE_SIZE/2, tileY + TILE_SIZE/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (grid[y][x] === BONUS) {
                        // Бонусы
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(tileX + 5, tileY + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                        ctx.fillStyle = '#FFF';
                        ctx.font = '10px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', tileX + TILE_SIZE/2, tileY + TILE_SIZE/2);
                    }
                }
            }
        }

        // Инициализация игры
        function initGame() {
            createLevel();
            player = new Player();
            
            // Создание призраков
            ghosts = [
                new Ghost(15 * TILE_SIZE, 10 * TILE_SIZE, '#E62E2E'),
                new Ghost(16 * TILE_SIZE, 10 * TILE_SIZE, '#FF8C00'),
                new Ghost(15 * TILE_SIZE, 11 * TILE_SIZE, '#FF8C8C'),
                new Ghost(16 * TILE_SIZE, 11 * TILE_SIZE, '#8A2BE2')
            ];

            powerMode = false;
            powerModeTimer = 0;
            gameRunning = true;
            
            updateUI();
        }

        // Обновление интерфейса
        function updateUI() {
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            levelEl.textContent = level;
            partsEl.textContent = `${dotsCollected}/${totalDots}`;
        }

        // Проверка столкновений
        function checkCollisions() {
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(
                    Math.pow(player.x - ghost.x, 2) + 
                    Math.pow(player.y - ghost.y, 2)
                );

                if (distance < TILE_SIZE / 2) {
                    if (powerMode) {
                        // Игрок ест призрака
                        ghost.x = 15 * TILE_SIZE;
                        ghost.y = 10 * TILE_SIZE;
                        score += 200;
                        updateUI();
                    } else {
                        // Призрак ловит игрока
                        lives--;
                        updateUI();
                        
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            player.reset();
                        }
                    }
                }
            });
        }

        // Проверка завершения уровня
        function checkLevelComplete() {
            if (dotsCollected >= totalDots) {
                levelComplete();
            }
        }

        // Завершение уровня
        function levelComplete() {
            gameRunning = false;
            levelCompleteEl.style.display = 'block';
        }

        // Конец игры
        function gameOver() {
            gameRunning = false;
            finalScoreEl.textContent = score;
            gameOverEl.style.display = 'block';
        }

        // Следующий уровень
        function nextLevel() {
            level++;
            levelCompleteEl.style.display = 'none';
            initGame();
        }

        // Перезапуск игры
        function restartGame() {
            score = 0;
            lives = 3;
            level = 1;
            gameOverEl.style.display = 'none';
            levelCompleteEl.style.display = 'none';
            initGame();
        }

        // Основной игровой цикл
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Очистка canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameRunning) {
                // Обновление режима силы
                if (powerMode) {
                    powerModeTimer--;
                    ghosts.forEach(ghost => ghost.frightened = true);
                    if (powerModeTimer <= 0) {
                        powerMode = false;
                        ghosts.forEach(ghost => ghost.frightened = false);
                    }
                }

                // Отрисовка уровня
                drawLevel();

                // Обновление и отрисовка игрока
                player.update(deltaTime);
                player.draw();

                // Обновление и отрисовка призраков
                ghosts.forEach(ghost => {
                    ghost.update(deltaTime);
                    ghost.draw();
                });

                // Проверка столкновений
                checkCollisions();

                // Проверка завершения уровня
                checkLevelComplete();
            }

            // Запрос следующего кадра
            requestAnimationFrame(gameLoop);
        }

        // Обработка клавиатуры
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': player.setDirection(UP); break;
                case 'ArrowRight': player.setDirection(RIGHT); break;
                case 'ArrowDown': player.setDirection(DOWN); break;
                case 'ArrowLeft': player.setDirection(LEFT); break;
                case ' ':
                    if (!gameRunning) {
                        restartGame();
                    }
                    break;
            }
        });

        // Мобильное управление
        document.getElementById('upBtn').addEventListener('touchstart', (e) => {
            player.setDirection(UP);
            e.preventDefault();
        });
        
        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            player.setDirection(RIGHT);
            e.preventDefault();
        });
        
        document.getElementById('downBtn').addEventListener('touchstart', (e) => {
            player.setDirection(DOWN);
            e.preventDefault();
        });
        
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            player.setDirection(LEFT);
            e.preventDefault();
        });

        // Запуск игры
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>